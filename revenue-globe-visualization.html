<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Revenue Dashboard</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background-color: #1a1a2e;
            color: white;
        }
        
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        
        #globe-container {
            flex: 3;
            position: relative;
        }
        
        #globe-canvas {
            width: 100%;
            height: 100%;
        }
        
        #dashboard {
            flex: 1;
            background-color: #16213e;
            padding: 20px;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            min-width: 300px;
        }
        
        #title {
            text-align: center;
            margin-bottom: 30px;
            color: #e94560;
        }
        
        #info-panel {
            position: absolute;
            left: 20px;
            top: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            pointer-events: none;
        }
        
        #country-info {
            display: none;
        }
        
        #top-countries {
            margin-top: 20px;
        }
        
        .country-bar {
            margin-bottom: 15px;
            position: relative;
        }
        
        .country-name {
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }
        
        .bar-container {
            width: 100%;
            height: 15px;
            background-color: #0f3460;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .bar-fill {
            height: 100%;
            border-radius: 10px;
            background: linear-gradient(90deg, #e94560, #ff9a8b);
            transition: width 1s ease;
        }
        
        .legend {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid #e94560;
        }
        
        .legend-title {
            margin-bottom: 15px;
        }
        
        .legend-gradient {
            height: 20px;
            width: 100%;
            background: linear-gradient(90deg, #192841, #0f3460, #533483, #e94560);
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        .legend-labels {
            display: flex;
            justify-content: space-between;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        
        .spinner {
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top: 5px solid #e94560;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #total-revenue {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 30px;
            color: #e94560;
        }
        
        #total-revenue-value {
            font-weight: bold;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background-color: #0f3460;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            flex: 1;
            margin: 0 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #e94560;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #cccccc;
        }
    </style>
    <!-- Import map to load Three.js modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
            }
        }
    </script>
    <!-- Add this in the head section, after the importmap -->
    <script src="https://unpkg.com/topojson-client@3"></script>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading globe data...</div>
    </div>
    
    <div id="container">
        <div id="globe-container">
            <canvas id="globe-canvas"></canvas>
            <div id="info-panel">
                <div id="country-info">
                    <h3 id="country-name">Country Name</h3>
                    <p>Revenue: <span id="country-revenue">$0</span></p>
                    <p>Percentage: <span id="country-percentage">0%</span></p>
                    <p>Rank: <span id="country-rank">#0</span></p>
                </div>
                <div id="hover-instructions">Hover over a country to see details</div>
            </div>
            <div id="tooltip" class="tooltip"></div>
        </div>
        
        <div id="dashboard">
            <h1 id="title">Global Revenue Dashboard</h1>
            
            <div id="total-revenue">
                <div class="stat-label">Total Revenue</div>
                <div id="total-revenue-value">$10,243,500</div>
            </div>
            
            <div class="stats-row">
                <div class="stat-card">
                    <div class="stat-value">142</div>
                    <div class="stat-label">Active Markets</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">24.8%</div>
                    <div class="stat-label">YoY Growth</div>
                </div>
            </div>
            
            <h2>Top Revenue Countries</h2>
            <div id="top-countries">
                <!-- Top countries will be inserted here -->
            </div>
            
            <div class="legend">
                <h3 class="legend-title">Revenue Scale</h3>
                <div class="legend-gradient"></div>
                <div class="legend-labels">
                    <span>Low</span>
                    <span>High</span>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Sample revenue data by country (ISO code: revenue in millions)
        const revenueData = {
            USA: 3250.5,
            CHN: 1650.2,
            JPN: 1200.8,
            DEU: 980.3,
            GBR: 875.6,
            IND: 765.9,
            FRA: 630.7,
            CAN: 580.4,
            AUS: 520.1,
            BRA: 480.3,
            KOR: 410.6,
            MEX: 330.5,
            ESP: 310.2,
            RUS: 280.5,
            ITA: 270.6,
            NLD: 220.8,
            SGP: 190.4,
            CHE: 180.5,
            SWE: 160.3,
            ARE: 140.7
        };
        
        // Add some revenue to all countries for better visualization
        const countryCodes = [
            "AFG", "ALB", "DZA", "AND", "AGO", "ATG", "ARG", "ARM", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BTN", "BOL", "BIH", 
            "BWA", "BRA", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CAF", "TCD", "CHL", "CHN", "COL", "COM", "COG", "COD", "CRI", "CIV", "HRV", "CUB",
            "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FJI", "FIN", "FRA", "GAB", "GMB", "GEO", "DEU", "GHA", "GRC",
            "GRD", "GTM", "GIN", "GNB", "GUY", "HTI", "HND", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "ISR", "ITA", "JAM", "JPN", "JOR", "KAZ", "KEN", "KIR",
            "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MRT",
            "MUS", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NZL", "NIC", "NER", "NGA", "NOR", "OMN", "PAK", "PLW",
            "PAN", "PNG", "PRY", "PER", "PHL", "POL", "PRT", "QAT", "ROU", "RUS", "RWA", "KNA", "LCA", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE",
            "SGP", "SVK", "SVN", "SLB", "SOM", "ZAF", "SSD", "ESP", "LKA", "SDN", "SUR", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TON",
            "TTO", "TUN", "TUR", "TKM", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "URY", "UZB", "VUT", "VEN", "VNM", "YEM", "ZMB", "ZWE"
        ];
        
        // Add base revenue for all countries not in our sample data
        countryCodes.forEach(code => {
            if (!revenueData[code]) {
                // Assign a random small revenue (1-100) for countries without specific data
                revenueData[code] = Math.floor(Math.random() * 100) + 1;
            }
        });
        
        // Sort countries by revenue for the top list
        const sortedCountries = Object.entries(revenueData)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);  // Top 10 countries
        
        // Calculate total revenue for percentages
        const totalRevenue = Object.values(revenueData).reduce((sum, value) => sum + value, 0);
        
        // Set up scene, camera, and renderer
        let scene, camera, renderer, controls;
        let globe, raycaster, mouse, intersectedObject;
        let countryInfoPanel, countryNameElement, countryRevenueElement, countryPercentageElement, countryRankElement, tooltipElement;
        let countryObjects = new Map();  // Store country objects for interaction
        
        // Country name mapping (ISO code to full name)
        const countryNames = {
            USA: "United States", CHN: "China", JPN: "Japan", DEU: "Germany", GBR: "United Kingdom",
            IND: "India", FRA: "France", CAN: "Canada", AUS: "Australia", BRA: "Brazil",
            KOR: "South Korea", MEX: "Mexico", ESP: "Spain", RUS: "Russia", ITA: "Italy",
            NLD: "Netherlands", SGP: "Singapore", CHE: "Switzerland", SWE: "Sweden", ARE: "United Arab Emirates"
        };
        
        init();
        
        async function init() {
            // Set up scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Set up camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth * 0.75 / window.innerHeight, 0.1, 1000);
            camera.position.z = 200;
            
            // Set up renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('globe-canvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth * 0.75, window.innerHeight);
            
            // Set up lighting
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Set up controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.5;
            controls.minDistance = 120;
            controls.maxDistance = 300;
            
            // Set up raycaster for interactions
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Get elements for info display
            countryInfoPanel = document.getElementById('country-info');
            countryNameElement = document.getElementById('country-name');
            countryRevenueElement = document.getElementById('country-revenue');
            countryPercentageElement = document.getElementById('country-percentage');
            countryRankElement = document.getElementById('country-rank');
            tooltipElement = document.getElementById('tooltip');
            
            // Create Earth Globe base
            const earthGeometry = new THREE.SphereGeometry(100, 64, 64);
            const earthMaterial = new THREE.MeshPhongMaterial({
                color: 0x192841,
                specular: 0x333333,
                shininess: 5,
                transparent: true,
                opacity: 0.9
            });
            globe = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(globe);
            
            // Add a slight glow effect
            const glowGeometry = new THREE.SphereGeometry(102, 64, 64);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x0066ff,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            scene.add(glowMesh);
            
            // Create grid lines (latitude/longitude) - Updated for BufferGeometry
            const gridMaterial = new THREE.LineBasicMaterial({ color: 0x3a3a5c, transparent: true, opacity: 0.3 });
            
            // Longitude lines
            for (let i = 0; i < 24; i++) {
                const points = [];
                const radius = 100;
                const segments = 64;
                const phiStart = 0;
                const phiLength = Math.PI * 2;
                
                // Create circle points
                for (let j = 0; j <= segments; j++) {
                    const segment = phiStart + j / segments * phiLength;
                    points.push(new THREE.Vector3(
                        radius * Math.cos(segment),
                        0,
                        radius * Math.sin(segment)
                    ));
                }
                
                const longitudeGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const longitudeLine = new THREE.Line(longitudeGeometry, gridMaterial);
                
                // Rotate to proper position
                longitudeLine.rotation.x = Math.PI / 2;
                longitudeLine.rotation.y = (i * Math.PI) / 12;
                
                globe.add(longitudeLine);
            }
            
            // Latitude lines
            for (let i = 1; i < 6; i++) {
                const latRadius = 100 * Math.sin((i * Math.PI) / 12);
                const points = [];
                const segments = 64;
                
                // Create circle points
                for (let j = 0; j <= segments; j++) {
                    const segment = j / segments * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        latRadius * Math.cos(segment),
                        0,
                        latRadius * Math.sin(segment)
                    ));
                }
                
                const latitudeGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const latitudeLine = new THREE.Line(latitudeGeometry, gridMaterial);
                
                // Position the line
                latitudeLine.rotation.x = Math.PI / 2;
                latitudeLine.position.y = 100 * Math.cos((i * Math.PI) / 12);
                globe.add(latitudeLine);
                
                // Add southern hemisphere lines
                if (i > 0) {
                    const southLine = latitudeLine.clone();
                    southLine.position.y = -100 * Math.cos((i * Math.PI) / 12);
                    globe.add(southLine);
                }
            }
            
            // Load GeoJSON data and create actual country boundaries
            try {
                const response = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
                const worldData = await response.json();
                createCountriesFromGeoJSON(worldData);
                
                // Initialize UI elements with the new color scheme
                initializeUI();
            } catch (error) {
                console.error("Error loading world data:", error);
                // Fallback to simulated countries if GeoJSON fails to load
                createSimulatedCountries();
                
                // Initialize UI even with fallback data
                initializeUI();
            }
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onMouseClick);
            
            // Start animation
            animate();
        }
        
        function createSimulatedCountries() {
            // Create simplified country representations
            console.log("Using simulated country data");
            
            // Create a parent object for all countries
            const countriesGroup = new THREE.Group();
            globe.add(countriesGroup);
            
            // We'll create simple spherical quads to represent major countries
            const countryKeys = Object.keys(revenueData);
            
            for (let i = 0; i < countryKeys.length; i++) {
                const countryCode = countryKeys[i];
                const revenue = revenueData[countryCode];
                const normalizedRevenue = normalizeRevenue(revenue);
                
                // Simple algorithm to distribute countries across the globe
                const phi = Math.acos(-1 + (2 * i) / countryKeys.length);
                const theta = Math.sqrt(countryKeys.length * Math.PI) * phi;
                
                // Calculate positions on sphere
                const x = Math.sin(phi) * Math.cos(theta) * 100;
                const y = Math.sin(phi) * Math.sin(theta) * 100;
                const z = Math.cos(phi) * 100;
                
                // Create country representation
                const countryGeometry = new THREE.BoxGeometry(
                    10 + normalizedRevenue * 5, 
                    10 + normalizedRevenue * 5, 
                    2 + normalizedRevenue * 3
                );
                
                // Color based on revenue
                const countryMaterial = new THREE.MeshPhongMaterial({
                    color: getColorFromRevenue(normalizedRevenue),
                    transparent: true,
                    opacity: 0.8,
                    emissive: getColorFromRevenue(normalizedRevenue),
                    emissiveIntensity: 0.2
                });
                
                const country = new THREE.Mesh(countryGeometry, countryMaterial);
                
                // Position the country on the globe surface
                country.position.set(x, y, z);
                
                // Orient the country to face outward from the center of the globe
                country.lookAt(0, 0, 0);
                country.rotation.z = Math.random() * Math.PI; // Random rotation for variety
                
                // Push the country outward slightly
                const direction = new THREE.Vector3(x, y, z).normalize();
                country.position.add(direction.multiplyScalar(1 + normalizedRevenue));
                
                // Store the country data for interaction
                country.userData = {
                    code: countryCode,
                    name: countryNames[countryCode] || countryCode,
                    revenue: revenue,
                    percentage: (revenue / totalRevenue * 100).toFixed(2) + '%',
                    rank: sortedCountries.findIndex(c => c[0] === countryCode) + 1
                };
                
                // Add to the collection
                countriesGroup.add(country);
                countryObjects.set(countryCode, country);
            }
        }
        
        function createCountriesFromGeoJSON(worldData) {
            console.log("Creating countries from GeoJSON data");
            
            // Create a parent object for all countries
            const countriesGroup = new THREE.Group();
            globe.add(countriesGroup);
            
            try {
                // Convert TopoJSON to GeoJSON features
                const countries = topojson.feature(worldData, worldData.objects.countries);
                console.log("Countries converted:", countries);
                
                // Process each country
                countries.features.forEach(country => {
                    try {
                        // Get ISO code from the feature
                        const countryId = country.id;
                        // Convert numeric ID to ISO3 code if available, or use as is
                        const countryCode = countryId.toString();
                        
                        // Set a default revenue for countries not in our data
                        const revenue = revenueData[countryCode] || Math.floor(Math.random() * 100) + 1;
                        const normalizedRevenue = normalizeRevenue(revenue);
                        
                        // Create material for the country
                        const countryMaterial = new THREE.MeshPhongMaterial({
                            color: getColorFromRevenue(normalizedRevenue),
                            transparent: true,
                            opacity: 0.8,
                            emissive: getColorFromRevenue(normalizedRevenue),
                            emissiveIntensity: 0.2
                        });
                        
                        // Process geometry based on type
                        if (country.geometry && country.geometry.type === "Polygon") {
                            createCountryMesh(country.geometry.coordinates, countryCode, revenue, normalizedRevenue, countryMaterial, countriesGroup);
                        } 
                        else if (country.geometry && country.geometry.type === "MultiPolygon") {
                            // Handle multiple polygons for a single country
                            country.geometry.coordinates.forEach(polygonCoords => {
                                createCountryMesh(polygonCoords, countryCode, revenue, normalizedRevenue, countryMaterial, countriesGroup);
                            });
                        }
                    } catch (countryError) {
                        console.error("Error processing country:", countryError);
                    }
                });
            } catch (error) {
                console.error("Error in GeoJSON processing:", error);
                // Fallback to simple countries if needed
                createSimulatedCountries();
            }
        }
        
        function createCountryMesh(polygonCoords, countryCode, revenue, normalizedRevenue, material, countriesGroup) {
            try {
                // Get the first ring of coordinates (outer boundary)
                const outerRing = polygonCoords[0];
                
                if (!Array.isArray(outerRing) || outerRing.length < 3) {
                    console.warn(`Invalid polygon data for country ${countryCode}`);
                    return;
                }
                
                // Create a list of points on the globe's surface
                const points = [];
                const baseRadius = 100; // Globe radius
                const extrudeHeight = 1 + normalizedRevenue * 4; // Height based on revenue
                
                // Scale factors for the mesh
                const radiusInner = baseRadius;
                const radiusOuter = baseRadius + extrudeHeight;
                
                // Create vertices for the 3D mesh - both for inner and outer faces
                for (let i = 0; i < outerRing.length; i++) {
                    if (Array.isArray(outerRing[i]) && outerRing[i].length >= 2) {
                        const lon = outerRing[i][0];
                        const lat = outerRing[i][1];
                        
                        // Create points on the surface and slightly above it
                        const pointInner = latLonToVector3(lat, lon, radiusInner);
                        const pointOuter = latLonToVector3(lat, lon, radiusOuter);
                        
                        points.push({inner: pointInner, outer: pointOuter});
                    }
                }
                
                // Create geometry using BufferGeometry for better performance
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                // Add vertices to the buffer
                for (let i = 0; i < points.length; i++) {
                    // Add inner point
                    vertices.push(points[i].inner.x, points[i].inner.y, points[i].inner.z);
                    // Add outer point
                    vertices.push(points[i].outer.x, points[i].outer.y, points[i].outer.z);
                }
                
                // Create triangles for the inner surface (country area)
                // We'll use a simple fan triangulation from the center point
                if (points.length >= 3) {
                    // Calculate the center point of the country (average of all points)
                    const centerInner = new THREE.Vector3();
                    const centerOuter = new THREE.Vector3();
                    
                    for (let i = 0; i < points.length; i++) {
                        centerInner.add(points[i].inner);
                        centerOuter.add(points[i].outer);
                    }
                    
                    centerInner.divideScalar(points.length);
                    centerOuter.divideScalar(points.length);
                    
                    // Add center points to the vertices
                    const centerInnerIndex = vertices.length / 3;
                    vertices.push(centerInner.x, centerInner.y, centerInner.z);
                    
                    const centerOuterIndex = vertices.length / 3;
                    vertices.push(centerOuter.x, centerOuter.y, centerOuter.z);
                    
                    // Create triangles for inner surface (fan triangulation)
                    for (let i = 0; i < points.length; i++) {
                        const current = i * 2;
                        const next = ((i + 1) % points.length) * 2;
                        
                        // Inner surface triangles (country area)
                        indices.push(current, next, centerInnerIndex);
                        
                        // Outer surface triangles (extruded part)
                        indices.push(current + 1, centerOuterIndex, next + 1);
                        
                        // Side triangles connecting inner and outer surfaces
                        indices.push(current, current + 1, next);
                        indices.push(next, current + 1, next + 1);
                    }
                } else {
                    // Fallback for countries with too few points
                    for (let i = 0; i < points.length - 1; i++) {
                        const current = i * 2;
                        const next = (i + 1) * 2;
                        
                        // Only render the outer faces and sides
                        // Outer face triangles (extruded part)
                        indices.push(current + 1, next + 1, current);
                        indices.push(next + 1, next, current);
                        
                        // Side triangles connecting inner and outer surfaces
                        indices.push(current, next, current + 1);
                        indices.push(next, next + 1, current + 1);
                    }
                    
                    // Close the loop for the fallback case
                    if (points.length > 2) {
                        const last = (points.length - 1) * 2;
                        const first = 0;
                        
                        indices.push(last + 1, first + 1, last);
                        indices.push(first + 1, first, last);
                        
                        indices.push(last, first, last + 1);
                        indices.push(first, first + 1, last + 1);
                    }
                }
                
                // Set geometry attributes
                geometry.setIndex(indices);
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.computeVertexNormals();
                
                // Create mesh and add to the globe
                const countryMesh = new THREE.Mesh(geometry, material);
                
                // Store country data for interaction
                countryMesh.userData = {
                    code: countryCode,
                    name: countryNames[countryCode] || countryCode,
                    revenue: revenue,
                    percentage: (revenue / totalRevenue * 100).toFixed(2) + '%',
                    rank: sortedCountries.findIndex(c => c[0] === countryCode) + 1
                };
                
                countriesGroup.add(countryMesh);
                countryObjects.set(countryCode, countryMesh);
            } catch (error) {
                console.error(`Error creating mesh for country ${countryCode}:`, error);
            }
        }
        
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lon + 180) * Math.PI / 180;
            
            const x = -radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            return new THREE.Vector3(x, y, z);
        }
        
        function normalizeRevenue(revenue) {
            // Get the maximum revenue for normalization
            const maxRevenue = Math.max(...Object.values(revenueData));
            return revenue / maxRevenue;
        }
        
        function getColorFromRevenue(normalizedRevenue) {
            // Define color gradient from low to high revenue using different shades of blue
            const lowColor = new THREE.Color(0x192841);    // Dark blue
            const mediumColor = new THREE.Color(0x2a6ab2); // Medium blue
            const highColor = new THREE.Color(0x4a9fff);   // Bright blue
            
            if (normalizedRevenue < 0.33) {
                return lowColor.lerp(mediumColor, normalizedRevenue * 3);
            } else {
                return mediumColor.lerp(highColor, (normalizedRevenue - 0.33) * 1.5);
            }
        }
        
        function populateTopCountries() {
            const topCountriesElement = document.getElementById('top-countries');
            topCountriesElement.innerHTML = '';
            
            let maxRevenue = sortedCountries[0][1];
            
            sortedCountries.forEach((country, index) => {
                const [code, revenue] = country;
                const name = countryNames[code] || code;
                const percentage = (revenue / totalRevenue * 100).toFixed(1);
                
                const countryElement = document.createElement('div');
                countryElement.className = 'country-bar';
                
                const nameRow = document.createElement('div');
                nameRow.className = 'country-name';
                
                const nameElement = document.createElement('span');
                nameElement.textContent = `${index + 1}. ${name}`;
                
                const valueElement = document.createElement('span');
                valueElement.textContent = `$${revenue.toLocaleString()}M`;
                
                nameRow.appendChild(nameElement);
                nameRow.appendChild(valueElement);
                
                const barContainer = document.createElement('div');
                barContainer.className = 'bar-container';
                
                const barFill = document.createElement('div');
                barFill.className = 'bar-fill';
                barFill.style.width = `${(revenue / maxRevenue) * 100}%`;
                
                barContainer.appendChild(barFill);
                
                countryElement.appendChild(nameRow);
                countryElement.appendChild(barContainer);
                
                // Add hover effect that highlights the country on the globe
                countryElement.addEventListener('mouseenter', () => {
                    const countryObject = countryObjects.get(code);
                    if (countryObject) {
                        if (intersectedObject) {
                            resetHighlight(intersectedObject);
                        }
                        highlightCountry(countryObject);
                        intersectedObject = countryObject;
                    }
                });
                
                countryElement.addEventListener('mouseleave', () => {
                    const countryObject = countryObjects.get(code);
                    if (countryObject) {
                        resetHighlight(countryObject);
                        intersectedObject = null;
                    }
                });
                
                topCountriesElement.appendChild(countryElement);
            });
        }
        
        function highlightCountry(object) {
            if (object.material) {
                // Store original material properties
                object.userData.originalColor = object.material.color.clone();
                object.userData.originalEmissive = object.material.emissive.clone();
                object.userData.originalEmissiveIntensity = object.material.emissiveIntensity;
                object.material.opacity = 1.0;
                object.material.color.set(0xffff99);  // Light yellow highlight
                object.material.emissive.set(0xffff00);
                object.material.emissiveIntensity = 0.7;
                
                // Show country info
                showCountryInfo(object);
            }
        }
        
        function resetHighlight(object) {
            if (object.material && object.userData.originalColor) {
                // Restore original material properties
                object.material.color.copy(object.userData.originalColor);
                object.material.emissive.copy(object.userData.originalEmissive);
                object.material.emissiveIntensity = object.userData.originalEmissiveIntensity;
                object.material.opacity = object.userData.originalOpacity;
                
                // Hide country info
                hideCountryInfo();
            }
        }
        
        function showCountryInfo(object) {
            const data = object.userData;
            
            // Update info panel
            countryNameElement.textContent = data.name;
            countryRevenueElement.textContent = `$${data.revenue.toLocaleString()}M`;
            countryPercentageElement.textContent = data.percentage;
            
            if (data.rank > 0) {
                countryRankElement.textContent = `#${data.rank}`;
            } else {
                countryRankElement.textContent = 'N/A';
            }
            
            // Show the info
            countryInfoPanel.style.display = 'block';
            document.getElementById('hover-instructions').style.display = 'none';
        }
        
        function hideCountryInfo() {
            countryInfoPanel.style.display = 'none';
            document.getElementById('hover-instructions').style.display = 'block';
        }
        
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update tooltip position
            tooltipElement.style.left = `${event.clientX + 10}px`;
            tooltipElement.style.top = `${event.clientY + 10}px`;
        }
        
        function onMouseClick(event) {
            // Optional: Add behavior for click on countries (e.g., detailed view)
            if (intersectedObject) {
                console.log('Clicked on:', intersectedObject.userData.name);
                // You could add more functionality here, like zooming to the country
                // or showing a detailed panel
            }
        }
        
        function checkIntersection() {
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // We need to find all the country meshes to check for intersections
            const countryMeshes = [];
            globe.traverse((object) => {
                // Check if this is a mesh with country data
                if (object.isMesh && object.userData && object.userData.code) {
                    countryMeshes.push(object);
                }
            });
            
            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(countryMeshes, false);
            
            if (intersects.length > 0) {
                // Get the first intersected country
                const intersectedCountry = intersects[0].object;
                
                if (intersectedObject !== intersectedCountry) {
                    // Restore previous intersected object
                    if (intersectedObject) {
                        resetHighlight(intersectedObject);
                    }
                    
                    // Highlight new intersected object
                    highlightCountry(intersectedCountry);
                    
                    // Update tooltip with country info
                    tooltipElement.innerHTML = `
                        <strong>${intersectedCountry.userData.name}</strong><br>
                        Revenue: $${intersectedCountry.userData.revenue.toLocaleString()}M<br>
                        ${intersectedCountry.userData.percentage} of global revenue
                    `;
                    
                    tooltipElement.style.display = 'block';
                    
                    intersectedObject = intersectedCountry;
                }
            } else {
                if (intersectedObject) {
                    resetHighlight(intersectedObject);
                    intersectedObject = null;
                    tooltipElement.style.display = 'none';
                }
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth * 0.75 / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth * 0.75, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Slowly rotate the globe for aesthetic
            globe.rotation.y += 0.001;
            
            // Check for intersections with the mouse
            checkIntersection();
            
            // Update controls
            controls.update();
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Update legend gradient to match blue color scheme
        function updateLegendColors() {
            const legendGradient = document.querySelector('.legend-gradient');
            if (legendGradient) {
                legendGradient.style.background = 'linear-gradient(90deg, #192841, #2a6ab2, #4a9fff)';
            }
        }
        
        // Call this function after initialization to update the legend colors
        function initializeUI() {
            // Update the legend colors to match the new blue scheme
            updateLegendColors();
            
            // Update total revenue display
            document.getElementById('total-revenue-value').textContent = `$${Math.round(totalRevenue).toLocaleString()}M`;
            
            // Populate top countries list
            populateTopCountries();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
        }
    </script>
</body>
</html> 